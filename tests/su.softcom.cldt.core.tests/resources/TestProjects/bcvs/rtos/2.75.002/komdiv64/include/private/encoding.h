#ifndef _ENCODING_H_
#define _ENCODING_H_

#include <wchar.h>

/* ошибка при выполнении xxx_mbtowc - некорректная последовательность байтов */
#define RET_ILSEQ    -1
/* была прочитана только сдвиговая последовательность из n байт (xxx_mbtowc) */
#define RET_TOOFEW   -2
/* ошибка при выполнении xxx_wctomb - некорректная кодовая позиция           */
#define RET_ILUNI    -1
/* в выходном буфере не хватает места (xxx_wctomb, xxx_reset)                */
#define RET_TOOSMALL -2 

#define ENC_NAME_LEN    20

typedef struct encMbtowcFuncs 
{
    /* Преобразует байтовую последовательность по адресу s в широкий символ,
     * записываемый по адресу pwc. Считывается максимум n байт (n >= 1).
     * 
     * Аргументы:
     *   econv - описатель состояния преобразования;
     *   pwc   - адрес, по которому записывается результат;
     *   s     - адрес исходной байтовой последовательности;
     *   n     - максимальное количество считываемых байтов; n>= 1.
     * 
     * Возвращаемое значение:
     *   Количество считанных байтов, если широкий символ был успешно получен.
     *   В противном случае:
     *     RET_ILSEQ  - некорректная байтовая последовательность;
     *     RET_TOOFEW - значение n недостаточно велико для считывания целого символа;
     *     -2-S       - если считана сдвиговая последовательность из S байтов.
     */
    int (*cf_mbtowc) (mbstate_t *econv, wchar_t *pwc, unsigned char const *s, int n);

    /* Возврат в начальное состояние и сохраняет ожидающий широкий символ (если
     * таковой есть).
     * 
     * Аргументы:
     *   econv - описатель состояния преобразования;
     *   pwc   - адрес, по которому записывается результат.
     * 
     * Возвращаемое значение:
     *   1, если широкий символ успешно записан, 0, если нечего записывать.
     */
    int (*cf_flushwc) (mbstate_t *econv, wchar_t *pwc);
    
} ENC_MBTOWC_FUNCS;

typedef struct encWctombFuncs 
{
    /* Преобразует широкий символ wc в байтовую последовательность,
     * записываемую по адресу r. Записывается максимум n байтов.
     * 
     * Аргументы:
     *   econv - описатель состояния преобразования;
     *   r     - адрес, по которому записывается результат;
     *   wc    - преобразуемый широкий символ;
     *   n     - максимальное число записываемых байтов в результате;
     *           n >= 1.
     * 
     * Возвращаемое значение:
     *   Количество байтов в результирующей последовательности в случае успешного
     *   преобразования. В противном случае:
     *     RET_ILUNI    - ошибка преобразования (некорректная кодовая позиция);
     *     RET_TOOSMALL - значение n не позволяет сформировать целый символ.
     */
    int (*cf_wctomb) (mbstate_t *econv, unsigned char *r, wchar_t wc, int n);

    /* Сохраняет сдвиговые последовательности по адресу r, возвращаясь в
     * начальное состояние. Записывается максимум n байтов.
     * 
     * Аргументы:
     *   econv - описатель состояния преобразования;
     *   r     - адрес, по которому записывается результат;
     *   n     - максимальное число записываемых байтов; n >= 0.
     * 
     * Возвращаемое значение:
     *   Количество записанных байтов в случае успеха. В противном случае
     *   RET_TOOSMALL (значение n не позволяет записать требуемый объем).
     */
    int (*cf_reset) (mbstate_t *econv, unsigned char *r, int n);

} ENC_WCTOMB_FUNCS;

/* Структура описания кодировки */
typedef struct encEncoding
{
    char            *name;
    ENC_WCTOMB_FUNCS wtom; /* функции преобразования WCHAR->Multibyte */
    ENC_MBTOWC_FUNCS mtow; /* функции преобразования Multibyte->WCHAR */
    int              mtowFlags; /* параметры преобразования           */
} ENC_BASE;

void encInitEncoding();
int encLookupEncoding(const char *name, ENC_BASE **encoding);
int locGetEncoding(int category, ENC_BASE **enc); /* in setlocale.c */

#endif /*_ENCODING_H_*/
