// fdim() - функция вычисления положительной разности двух чисел типа double.
//
// Синтаксис:
//   #include <math.h>
//   double fdim( double x, double y );
//
// Возвращаемое значение:
//   Если число x больше числа у, то функция возвращает
//   положительную разность двух чисел: (x-y).
//   Если число х меньше либо равно у, функция возвращает число +0.
//
// Особые значения:
//   Если хотя бы один из аргументов равен NaN, то функция возвращает NaN.
//
// Ошибки:
//   Если в результат (x-y) положительный и возникает переполнение (overflow),
//   то функция возвращает HUGE_VAL и переменной errno присваивает код ошибки [ERANGE].
//
// Cтандарт: функция соответствует стандарту POSIX 1003.1, 2004 г.


// Новый алгоритм!!
//
// 1. Вычисляем Ex = exp(x) и Ey = exp(y).
//    Функция exp() возвращает смещенный (biased) показатель степени (порядок).
//    Emax - максимальное значение порядка, минимальное значение равно 0.
// 2. Eсли Ex >= Emax-1 и Ey >= Emax-1
// 2.1  Если x или y равно NaN, возвращаем NaN.
//
// 2.2  Если x=+inf
// 2.2.1 Если y=+inf, то взвращаем +0
// 2.2.2 Иначе возвращаем HUGE_VAL и errno = [ERANGE].
// 2.3. Если x=-inf, то взвращаем +0
//
// 2.4. Если y=+inf, то возвращаем +0.
// 2.5. Если y=-inf, возвращаем HUGE_VAL и errno = [ERANGE] (случай x=-inf был рассмотрен выше).
//
// 2.6. Eсли Ex = Emax-1, то x1=x/2
// 2.6.1 Если Ey <= 1, но y!=0, то y1=DBL_MIN со знаком y. Иначе y1=y/2
// 2.6.2 Если (x1-y1) <= 0, то возвращаем +0.
//       Иначе возвращаем 2*(x1-y1), вычисленное с помощью ldexp().
//
// 2.7. Eсли Ey = Emax-1, то y1=y/2
// 2.7.1 Если Ex <= 1, но x!=0, то x1=DBL_MIN со знаком x. Иначе x1=x/2
// 2.7.2 Если (x1-y1) <= 0, то возвращаем +0.
//       Иначе возвращаем 2*(x1-y1), вычисленное с помощью ldexp() .
//
// 3. Если Ex<=52 (возможно, х - денормализованное число)
// 3.1. Если Ey<Emax-105
//      Если (x*2**104-y*2**104) > 0, то возвращаем ((2**(-104))*(x*2**104-y*2**104), иначе +0.
//      Результат может быть денормализованным числом.
// 3.2. Если x=0
//      Если y<0, то возвращаем -y, иначе +0.
// 3.3. Иначе (Ey>=Emax-105)
//      y1=y/2, x1 = DBL_MIN со знаком x.
//      Если (x1-y1) <= 0, то возвращаем +0.
//      Если (x1-y1) < DBL_MAХ/2, то возвращаем 2*(x1-y1), иначе возвращаем HUGE_VAL и errno = [ERANGE].
//
// 4. Если Ey<=52
// 4.1. Если Ex<Emax-105
//      Если (x*2**104-y*2**104) > 0, то возвращаем ((2**(-104))*(x*2**104-y*2**104), иначе +0.
//      Результат может быть денормализованным числом.
// 4.2. Если y=0
//      Если x>0, то возвращаем х, иначе +0.
// 4.3. Иначе (Ex>=Emax-105)
//      x1=x/2, y1 = DBL_MIN со знаком у.
//      Если (x1-y1) <= 0, то возвращаем +0.
//      Если (x1-y1) < DBL_MAХ/2, то возвращаем 2*(x1-y1), иначе возвращаем HUGE_VAL и errno = [ERANGE].
//
// 5. Теперь 52>Ex>=Emax-1 или  52>Ey>=Emax-1
//    Если x<=y, возвращаем +0, иначе x-y
//
// Замечание. При округлении к +Inf следующие неравенства неэвивалентны:
//            x-y <= DLB_MAX и x <= DLB_MAX + y
// Действительно, пусть x = DLB_MAX,
//            y = -epsilon/2 (epsilon соответствует последнему биту в мантиссе DLB_MAX)
// При округлении к +Inf
//            x-y при округлении вызывает переполнение (результат больше DLB_MAX),
//            DLB_MAX + y при округлении дает DLB_MAX.
//
//
//    Тестируем при
//               x=DBL_MIN*(2**51), y = (2*x - DBL_MIN)/2
//               x=DLB_MIN,         y = DLB_MIN(1-1**(-52))
//               x=DBL_MAX, y = - DBL_MIN (при округлении к ближайшему и к плюс бесконечности)
//               x=DBL_MAX, y =   DBL_MIN (при округлении к ближайшему и к нулю)

#if( !defined( __MATH_INLINE_FDIM_H__ ))
#define __MATH_INLINE_FDIM_H__

#if( defined( BT_MATH_INLINE )) 
#if( defined( BT_MATH_NOCHECK ) || defined( BT_MATH_NORMAL ))

#define fdim MATH_INLINE_FDIM

#endif // BT_MATH_NORMAL || BT_MATH_NOCHECK
#endif // BT_MATH_INLINE
static double __inline__ __UNUSED_F MATH_INLINE_FDIM( double x, double y )
{
   if( x <= y )
   {
        // Неположительная разность: ( x - y ) <= 0.0
        return( +0.0 );
   }
#if( !defined( BT_MATH_NOCHECK ))
   if(( y < 0 ) && ( x > y + DBL_MAX ))
   {
      // Переполнение: ( x - y ) > DBL_MAX
      errno = ERANGE;
      return( HUGE_VAL );
   }
#endif // BT_MATH_NOCHECK
   return( x - y );         // возвращаем положительную разность
}

#endif // __MATH_INLINE_FDIM_H__

